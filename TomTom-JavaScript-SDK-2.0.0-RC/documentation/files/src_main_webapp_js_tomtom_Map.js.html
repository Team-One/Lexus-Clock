<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;main&#x2F;webapp&#x2F;js&#x2F;tomtom&#x2F;Map.js - TomTom JavaScript SDK</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;www.tomtom.com&#x2F;global&#x2F;images&#x2F;tomtom-logo_tcm166-3340.png" title="TomTom JavaScript SDK"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0-RC</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/L.Control.Pan.html">L.Control.Pan</a></li>
            
                <li><a href="..&#x2F;classes/L.Control.ZoomSlider.html">L.Control.ZoomSlider</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.AjaxUtil.html">tomtom.AjaxUtil</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.Animation.html">tomtom.Animation</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.controls.AutoComplete.html">tomtom.controls.AutoComplete</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.controls.ContextMenu.html">tomtom.controls.ContextMenu</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.controls.FindLocationControl.html">tomtom.controls.FindLocationControl</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.controls.PanZoomBar.html">tomtom.controls.PanZoomBar</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.controls.RouteControl.html">tomtom.controls.RouteControl</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.controls.RoutePlannerControl.html">tomtom.controls.RoutePlannerControl</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.controls.TabContainer.html">tomtom.controls.TabContainer</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.CustomDivIcon.html">tomtom.CustomDivIcon</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.CustomMarker.html">tomtom.CustomMarker</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.dom.DomUtil.html">tomtom.dom.DomUtil</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.dom.DomUtilResult.html">tomtom.dom.DomUtilResult</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.layers.MapLayer.html">tomtom.layers.MapLayer</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.layers.TrafficIncidentLayer.html">tomtom.layers.TrafficIncidentLayer</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.layers.TrafficLayer.html">tomtom.layers.TrafficLayer</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.layers.WMSLayer.html">tomtom.layers.WMSLayer</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.LocaleManager.html">tomtom.LocaleManager</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.Main.html">tomtom.Main</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.Map.html">tomtom.Map</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.Marker.html">tomtom.Marker</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.MarkerManager.html">tomtom.MarkerManager</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.services.GeocodingService.html">tomtom.services.GeocodingService</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.services.GeocodingServiceV4.html">tomtom.services.GeocodingServiceV4</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.services.HDTRegionsService.html">tomtom.services.HDTRegionsService</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.services.InitializeService.html">tomtom.services.InitializeService</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.services.RoutingService.html">tomtom.services.RoutingService</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.services.TrafficService.html">tomtom.services.TrafficService</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.services.ViewportService.html">tomtom.services.ViewportService</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.StringBundle.html">tomtom.StringBundle</a></li>
            
                <li><a href="..&#x2F;classes/tomtom.TrafficMarker.html">tomtom.TrafficMarker</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;main&#x2F;webapp&#x2F;js&#x2F;tomtom&#x2F;Map.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * The map widget allows a user to add a map to the page.
 * @author Kyle Pinette
 *&#x2F;
define([
		&quot;.&#x2F;Utils&quot;,
        &quot;.&#x2F;dom&#x2F;DomUtil&quot;,
		&quot;.&#x2F;Logger&quot;,
        &quot;.&#x2F;services&#x2F;InitializeService&quot;,
        &quot;.&#x2F;services&#x2F;ViewportService&quot;,
        &quot;.&#x2F;services&#x2F;RoutingService&quot;,
        &quot;.&#x2F;services&#x2F;GeocodingService&quot;,
        &quot;.&#x2F;layers&#x2F;MapLayer&quot;,
        &quot;.&#x2F;layers&#x2F;TrafficLayer&quot;,
        &quot;.&#x2F;layers&#x2F;TrafficIncidentLayer&quot;,
        &quot;.&#x2F;lib&#x2F;leaflet.minimap&quot;,
        &quot;.&#x2F;controls&#x2F;PanZoomBar&quot;,
        &quot;.&#x2F;controls&#x2F;ContextMenu&quot;
	],
	
	function(utils, du) {
		
		tomtom.Map = L.Map.extend({
			
			&#x2F;**
			 * Creates a new instance of a TomTom Map.  The map can be embedded multiple times on the same page.
			 * To create a map, supply an API key and a domNode for the map to append its markup to.  See the options parameter for all
			 * available options.
			 * 
			 * For documentation about the base Leaflet Map and other objects, see &lt;a href=&quot;http:&#x2F;&#x2F;leafletjs.com&#x2F;reference.html&quot;&gt;http:&#x2F;&#x2F;leafletjs.com&#x2F;reference.html&lt;&#x2F;a&gt;.
			 * 
			 * @example
			 * 	&#x2F;&#x2F; a basic map
			 * 	var map = new tomtom.Map({
			 * 		apiKey: &quot;123456&quot;,
			 * 		domNode: &quot;map&quot;
			 *	});
			 * 
			 * @constructor
			 * @class Map
			 * @namespace tomtom
			 * @extends L.Map
			 * @param {Object} options Options to supply to the map.
			 * @param {String|DOM Node} options.domNode The id of the DOM node, or the DOM node itself to use as the map container.
			 * @param {String} options.apiKey The API Key issued from &lt;a href=&quot;http:&#x2F;&#x2F;developer.tomtom.com&quot;&gt;http:&#x2F;&#x2F;developer.tomtom.com&lt;&#x2F;a&gt;.  This is optional if
			 * 	tomtom.apiKey has been set already.
			 * @param {Object|boolean} [options.cookie] pass true or false to enable or disable the use of a cookie to keep the map
			 * 	state across page views.
			 * 	Supply an object to customize cookie options.
			 * @param {String} [options.cookie.name] The name of the cookie to be written.
			 * @param {Number} [options.cookie.expirationDays] The number of days before the cookie will expire.
			 * @param {Array|L.LatLng} [options.center]The point where the map will be centered upon startup.  Please note that this option is
			 * 	overridden if the cookie option is enabled.
			 * @param {Number} [options.zoom] The zoom level the map will go to at startup.  The default is to zoom out to the lowest zoom level available.
			 * @param {Array} [options.layers] The layers to be added to the map at startup.  Any Leaflet layer &#x2F; TomTom layer can be used.
			 * 	By default, the tomtom.layers.MapLayer is added as the base layer.
			 * @param {Object|boolean} [options.overviewMap] If any non-false value is passed as this option, an overview map will be displayed.  If an Object is passed,
			 * 	the object will be passed as options to the overviewMap&#x27;s constructor constructor. See &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Norkart&#x2F;Leaflet-MiniMap&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;Norkart&#x2F;Leaflet-MiniMap&lt;&#x2F;a&gt; for available options.
			 * @param {Boolean} [options.scale] Determines whether or not to add the L.Control.Scale control to the map.  This control
			 * 	displays basic scale information on the map.
			 * @param {Boolean} [options.zoomControl] If any non-false value is passed as this option, a leaflet zoom control is added.
			 * @param {Boolean} [options.panZoomBar] If any non-false value is passed, the tomtom PanZoomBar control is added.
			 * 	If an Object is passed, the object will be passed to the {{#crossLink &quot;tomtom.controls.PanZoomBar&quot;}}tomtom.controls.PanZoomBar{{&#x2F;crossLink}} control&#x27;s constructor.
			 * @param {Boolean} [options.displayTraffic] Determines whether or not traffic incidents and flow information is included on the map.
			 * @param {Object} [options.baseLayerOptions] Options that will be passed to the base map layer.  Note that if options.layers is supplied, this option is not used.
			 *&#x2F;
			initialize: function(options) {
				
				if (!options)
					options = {};

				&#x2F;&#x2F; set up the logger
				this.log = new tomtom.Logger();
				
				&#x2F;&#x2F; get the API key
				this.apiKey = tomtom.apiKey;
				
				this._copyrightInfo = {};
				this._displayRouteId = 0;
				this._currentAttribution = &quot;&quot;;
				this._routeCallQueue = [];
				this._routeWaypoints = [];
				this._attributionClickHandlers = [];
				
				this.routeStyle = L.Util.extend({
					color: &quot;#0f0&quot;,
					weight: 8,
					opacity: 0.6
				}, options.routeStyle);
				
				if (options.apiKey)
					this.apiKey = options.apiKey;
				
				&#x2F;&#x2F; initialize the geocoding service
				if (options.geocodingService)
					this.geocodingService = options.geocodingService;
				else
					this.geocodingService = new tomtom.services.GeocodingService(this.apiKey);
				
				options.minZoom = 2;
				options.maxZoom = 17;
				
				&#x2F;&#x2F; check to see if a center position was supplied
				if (!options.center)
					options.center = [0, 0];
				
				if (!options.zoom)
					options.zoom = 2;
				
				&#x2F;&#x2F; we want to add a custom attribution control
				options.attributionControl = false;
				
				&#x2F;&#x2F; restore the location of the map if cookies are enabled
		        if (options.cookie) {
		        	
		        	if (typeof(options.cookie) != &quot;object&quot;)
		        		options.cookie = {};
		        	
		        	&#x2F;&#x2F; check to see if a cookie name was supplied
		        	if (!options.cookie.name)
		        		options.cookie.name = &quot;tomtom-map-extent&quot;;
		        	
		        	&#x2F;&#x2F; check to see if the cookie name is defined
		        	var cookie = utils.getCookie(options.cookie.name);
		        	
		        	&#x2F;&#x2F; make sure the cookie was found
		        	if (cookie) {
			        	var cookieVals = cookie.split(&quot;,&quot;);
			        	
			        	&#x2F;&#x2F; make sure the cookie is valid
			        	if (cookieVals.length &gt;= 3) {
				        	
			        		var lat = cookieVals[0].trim();
			        		var lng = cookieVals[1].trim();
			        		
			        		if (!isNaN(lat) &amp;&amp; !isNaN(lng)) {
			        			options.center = new L.LatLng(parseFloat(lat), parseFloat(lng));
			        			options.zoom = cookieVals[2].trim();
			        		}
				        	
			        	}
			        	
		        	}
		        	
		        }
		        
		        if (typeof(options.zoomControl) == &quot;undefined&quot;)
		        	options.zoomControl = false;
				
				L.Map.prototype.initialize.apply(this, [options.domNode, options]);
		        
		        &#x2F;&#x2F; set up the attribution control
		        this.attributionControl = new L.Control.Attribution({ position: &quot;bottomleft&quot;, prefix: &quot;&quot; }).addTo(this);
		        
				&#x2F;&#x2F; make a call to the initialize API
				var initialize = new tomtom.services.InitializeService(this.apiKey);
				
				initialize.getCopyrightInfo(L.Util.bind(function(response) {
					
					var copyrights = response.initializeResponse.copyright;
					
					for (var copyrightIndex = 0; copyrightIndex &lt; copyrights.length; copyrightIndex++) {
						
						var info = copyrights[copyrightIndex];
						
						if (info)
							this._copyrightInfo[info[&quot;@id&quot;]] = info;
						
					}
			        
			        &#x2F;&#x2F; create the traffic layers
			        if (options.displayTraffic)
			        	this.setDisplayTraffic(true);
			        else &#x2F;&#x2F; make sure the initial viewport is loaded
						this._updateViewport(false);
					
				}, this));
				
				if (!options.layers) {

					var layerOptions = L.Util.extend({ apiKey: this.apiKey }, options.baseLayerOptions || {});
					
					&#x2F;&#x2F; add the base map layer
					this._baseLayer = new tomtom.layers.MapLayer(layerOptions);
					this._baseLayer.on(&quot;load&quot;, this._fireLoad, this);
					this.addLayer(this._baseLayer);
					
				}
				
				&#x2F;&#x2F; check for scale option
				if (options.scale)
					L.control.scale().addTo(this);
				
				&#x2F;&#x2F; check for overviewMap option
				if (options.overviewMap) {
					
					minimapOptions = { toggleDisplay: true };
					
					if (typeof(options.overviewMap) == &quot;object&quot;)
						minimapOptions = options.overviewMap;
					
					this._miniMap = new L.Control.MiniMap(new tomtom.layers.MapLayer({ apiKey: this.apiKey }), minimapOptions).addTo(this);
				}
				
				&#x2F;&#x2F; check to see if the pan zoom bar needs to be added
				if (options.panZoomBar) {
					
					this._panZoomBar = new tomtom.controls.PanZoomBar();
					this._panZoomBar.addTo(this);
					
				}
				
				&#x2F;&#x2F; create a context menu for route waypoints
				this._waypointContextMenu = new tomtom.controls.ContextMenu({
					menuItems: [{ label: &quot;Remove waypoint&quot;, onClick: L.Util.bind(this._removeWaypoint, this) }]
				});
				this._waypointContextMenu.onAdd(this);
				
				&#x2F;&#x2F; wire up events
				this.on(&quot;moveend&quot;, this._handleMapMove, this);
				this.on(&quot;zoomend&quot;, this._handleZoomChange, this);
				this.on(&quot;mousemove&quot;, this._handleMouseMove, this);
				this.on(&quot;mouseup&quot;, this._handleMouseUp, this);
				
			},
			
			&#x2F;**
			 * Enables or disables live traffic display.
			 * @method setDisplayTraffic
			 * @param {Boolean} value Whether or not to display live traffic information on the map.
			 *&#x2F;
			setDisplayTraffic: function(value) {
				
				this._displayTraffic = value;
				
				if (value) {
					
					&#x2F;&#x2F; clear the update interval
					clearInterval(this._trafficUpdateIntervalId);
					
					this._updateViewport(true);
					
					&#x2F;&#x2F; update the traffic at a given interval
			        this._trafficUpdateIntervalId = setInterval(L.Util.bind(function() { this._updateViewport(true); }, this), TRAFFIC_UPDATE_INTERVAL);
					
				} else {
					
					if (this._trafficLayer) {
						this.removeLayer(this._trafficLayer);
						this._trafficLayer = null;
					}
					
					if (this._trafficIncidentLayer) {
						this.removeLayer(this._trafficIncidentLayer);
						this._trafficIncidentLayer = null;
					}
					
					&#x2F;&#x2F; clear the update interval
					clearInterval(this._trafficUpdateIntervalId);
					
				}
			},
			
			&#x2F;**
			 * Destroys the map and any resources it is holding onto.  This method will remove the Map&#x27;s inner contents from the DOM.
			 * @method destroy
			 *&#x2F;
			destroy: function() {
				
				&#x2F;&#x2F; clear any timeouts &#x2F; intervals
				clearTimeout(this._viewportUpdateTimeoutId);
				clearInterval(this._trafficUpdateIntervalId);
				
				&#x2F;&#x2F; remove any layers
				for (var layerId in this._layers) {
					
					this.removeLayer(this._layers[layerId]);
					
				}
				
				&#x2F;&#x2F; clean up any context menus
				if (this._contextMenus) {
					
					this._contextMenus.forEach(function(contextMenu) {
						contextMenu.onRemove(this);
					}, this);
					
					this._contextMenus = [];
					this._waypointContextMenu = null;
					
				}
				
				var handlers = [
					&quot;dragging&quot;, 
					&quot;scrollWheelZoom&quot;, 
					&quot;touchZoom&quot;, 
					&quot;keyboard&quot;, 
					&quot;doubleClickZoom&quot;, 
					&quot;boxZoom&quot;
				];
				
				handlers.forEach(function(name) {
					if (this[name]) this[name].removeHooks();
				}, this);
				
				this._container._leaflet = null;
				
				&#x2F;&#x2F; detach all events
				var events = this[&quot;_leaflet_events&quot;];
				
				for (var eventType in events) {
					
					var event = events[eventType];
					this.off(eventType, event.action, event.context);
					
				}
				
				&#x2F;&#x2F; detach MORE events
				L.DomEvent.off(this._container, &#x27;click&#x27;, this._onMouseClick, this);

				var events = [&#x27;dblclick&#x27;, &#x27;mousedown&#x27;, &#x27;mouseup&#x27;, &#x27;mouseenter&#x27;, &#x27;mouseleave&#x27;, &#x27;mousemove&#x27;, &#x27;contextmenu&#x27;],
					i, len;

				for (i = 0, len = events.length; i &lt; len; i++) {
					L.DomEvent.off(this._container, events[i], this._fireMouseEvent, this);
				}

				if (this.options.trackResize) {
					L.DomEvent.off(window, &#x27;resize&#x27;, this._onResize, this);
				}
				
				if (L.DomUtil.TRANSITION_END)
					L.DomEvent.off(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd);
				
				&#x2F;&#x2F; make sure the attribution control cleans itself up
				this._destroyAttribution();
				
				&#x2F;&#x2F; clean up the container
				var container = du.create(this._container);
				container.empty();
				
				var classNames = this._container.className.split(&quot; &quot;);
				
				classNames.forEach(function(className) {
					if (className.indexOf(&quot;leaflet&quot;) == 0)
						container.removeClass(className);
				});
				
				container.css(&quot;position&quot;, &quot;&quot;);
				
			},
			
			&#x2F;**
			 * Displays a route on the map using the TomTom Map Toolkit&#x27;s Routing call.
			 * @method displayRoute
			 * @param {Array} points The points which make up the route.  There must be at least 2 points, and at most 5 points specified.
			 * 	If the points are specified as strings, the Map will assume they are addresses and apply geocoding.  Leaflet L.LatLng objects can also be passed to
			 * use points instead of addresses.  Addresses and L.LatLng Objects can be intermixed within the points.
			 * @param {Object} [options] Options to pass to the Map Toolkit Routing call.
			 * @param {String} [options.key] The API key to use.
			 * @param {String} [options.routeType=Quickest] The route type to use.  Must be one of the following: 
			 * Quickest, Shortest, AvoidMotorway, Walk, Bicycle, SpeedLimited, Green.
			 * @param {Boolean} [options.avoidTraffic=false] Whether or not to avoid traffic when calculating the route.
			 * @param {String} [options.day=today] The day of departure.  Must be one of the following: today, tomorrow, monday, tuesday, wednesday, thursday, friday, saturday, sunday
			 * @param {String|Number} [options.time=now] Time of departure, either now or the number of minutes since midnight. 
			 * 	Note that now (default value) is only valid when day=today (default).
			 * @param {Boolean} [options.avoidTolls=false] Whether or not to avoid tolls when calculating the route.
			 * @param {Function} [callback] A callback to execute once the route has been executed.  The routing response is passed as the only argument to the callback
			 *  once the routing call has been completed.
			 *&#x2F;
			displayRoute: function(points, options, callback) {
				
				&#x2F;&#x2F; check to see if a routing call is active
				if (this._isRoutingExecuting) {
					
					this._routeCallQueue.push({ points: points, options: options, callback: callback });
					
				} else {
				
					this._isRoutingExecuting = true;
					
					if (typeof(options) == &quot;function&quot;) {
						callback = options;
						options = {};
					}
					
					&#x2F;&#x2F; make sure the options are not null
					options = options ? options : {};
					
					&#x2F;&#x2F; keep the original options
					this._currentRouteOptions = options;
					
					&#x2F;&#x2F; show a loading message
					if (typeof(options.showLoading) == &quot;undefined&quot; || options.showLoading)
						this.displayLoadingMessage(&quot;Calculating route...&quot;);
					
					this._displayRouteId++;
					this._routingCallback = callback;
					
					if (typeof(options.checkPoints) == &quot;undefined&quot; || options.checkPoints) {
						this._originalRoutePoints = points;
						this._routePoints = [];
						this._waypointsNeedUpdate = true;
						this._checkRoutePoints(this._displayRouteId, 0, options);
					} else
						this._getRoute(this._displayRouteId, options, typeof(options.updateBounds) == &quot;undefined&quot; ? true : options.updateBounds);
					
				}
				
			},
			
			&#x2F;**
			 * Highlights a route instruction for the currently displayed route.  This can be used to display a directional arrow at the instruction index specified.
			 * @method displayRouteInstruction
			 * @param {Number} instructionIndex The index of the instruction that should be highlighted.
			 *&#x2F;
			displayRouteInstruction: function(instructionIndex) {
				
				if (this._routeLayer) {
					var instruction = this._currentRoute.instructions.instruction[instructionIndex];
						
					&#x2F;&#x2F; zoom to the instruction
					this.setView([instruction.point.latitude, instruction.point.longitude], INSTRUCTION_ZOOM_LEVEL);
					
					L.popup().setLatLng([instruction.point.latitude, instruction.point.longitude])
						.setContent(L.Util.template(&quot;&lt;div class=\&quot;tt-instruction-popup\&quot;&gt;&lt;img src=\&quot;{iconUrl}\&quot; &#x2F;&gt;&lt;span class=\&quot;road\&quot;&gt;{text} {roadNumber} {roadName}&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;&quot;, {
							iconUrl: tomtom.baseImagePath + &quot;instructions&#x2F;&quot; + instruction.iconPath,
							roadName: instruction.roadName,
							roadNumber: instruction.roadNumber,
							text: instruction.text
						})).openOn(this);
				}
				
			},
			
			&#x2F;**
			 * Removes the current route from the map.
			 * @method clearRouting
			 *&#x2F;
			clearRouting: function() {
				
				if (this._routeLayer) {
					this.removeLayer(this._routeLayer);
					this._routeLayer = null;
				}
				
				if (this._routeMarkerLayer) {
					this.removeLayer(this._routeMarkerLayer);
					this._routeMarkerLayer = null;
				}
				
				this._startMarker = null;
				this._endMarker = null;
				this._currentRoute = null;
				
				&#x2F;&#x2F; clear the list of route calls
				this._routeCallQueue = [];
				
				&#x2F;&#x2F; clear route waypoints
				this._routeWaypoints.forEach(function(element) {
					this.removeLayer(element);
				}, this);
				
				this._routeWaypoints = [];
				
				&#x2F;&#x2F; clear the context menu targets
				this._waypointContextMenu.clearTargets();
				
			},
			
			&#x2F;**
			 * Gets the current route information.
			 * @method getCurrentRoute
			 * @returns {Object} The route response from the routing call.
			 *&#x2F;
			getCurrentRoute: function() {
				return this._currentRoute;
			},
			
			&#x2F;**
			 * Sets the context menu for the map.
			 * The context menu will be displayed when the user right clicks the map.
			 * @param {tomtom.ContextMenu} contextMenu The context menu to display when the map is right clicked.
			 *&#x2F;
			setContextMenu: function(contextMenu) {
				
				&#x2F;&#x2F; get rid of the old context menu
				if (this.contextMenu)
					this.contextMenu.onRemove(this);
				
				this.contextMenu = contextMenu;
				
				contextMenu.addTarget(this._container, this);
				
				if (!contextMenu.map)
					contextMenu.onAdd(this);
				
			},
			
			&#x2F;**
			 * Displays a modal loading message which will prevent the user from performing any action until hideLoadingMessage is called.
			 * @method displayLoadingMessage
			 * @param {String} message The message to be displayed along with the loading graphic.
			 *&#x2F;
			displayLoadingMessage: function(message) {
				
				if (!this._loadingBackdrop) {
					this._loadingBackdrop = L.DomUtil.create(&quot;div&quot;, &quot;loadingBackdrop&quot;);
					this._container.appendChild(this._loadingBackdrop);
				}
				
				if (!this._loadingMessage) {
					this._loadingMessage = L.DomUtil.create(&quot;div&quot;, &quot;loadingMessage&quot;);
					this._container.appendChild(this._loadingMessage);
					
					var image = L.DomUtil.create(&quot;div&quot;, &quot;image&quot;);
					this._loadingMessage.appendChild(image);
					
					var messageDiv = L.DomUtil.create(&quot;div&quot;, &quot;message&quot;);
					this._loadingMessage.appendChild(messageDiv);
				}
				
				du.query(&quot;.message&quot;, this._loadingMessage).html(message);
				this._loadingBackdrop.style.display = &quot;block&quot;;
				this._loadingMessage.style.display = &quot;block&quot;;
				
				&#x2F;&#x2F; position the message based on its dimensions
				this._loadingMessage.style.top = ((this._container.offsetHeight - this._loadingMessage.offsetHeight) &#x2F; 2) + &quot;px&quot;;
				this._loadingMessage.style.left = ((this._container.offsetWidth - this._loadingMessage.offsetWidth) &#x2F; 2) + &quot;px&quot;;
				
			},
			
			&#x2F;**
			 * Hides the loading message which is created by calling displayLoadingMessage.
			 * @method hideLoadingMessage
			 *&#x2F;
			hideLoadingMessage: function() {
				
				if (this._loadingBackdrop) {
					this._loadingBackdrop.style.display = &quot;none&quot;;
				}
				
				if (this._loadingMessage) {
					this._loadingMessage.style.display = &quot;none&quot;;
				}
				
			},
			
			&#x2F;**
			 * Gets the current traffic incidents that are being displayed.
			 * @method getTrafficIncidents
			 *&#x2F;
			getTrafficIncidents: function() {
				
				if (this._trafficIncidentLayer &amp;&amp; this._trafficIncidentLayer.incidents)
					return this._trafficIncidentLayer.incidents;
				else
					return null;
				
			},
			
			&#x2F;**
			 * Gets a traffic marker by the specified incident id.
			 * @method getTrafficMarkerByIncidentId
			 * @param id The incident id of the marker to retrieve.
			 * @returns The marker with the specified incident id.
			 *&#x2F;
			getTrafficMarkerByIncidentId: function(id) {
				
				var trafficLayer = this._trafficIncidentLayer;
				
				&#x2F;&#x2F; make sure traffic is loaded
				if (trafficLayer) {
					
					&#x2F;&#x2F; loop through each marker
					for (var layerId in trafficLayer._layers) {
						
						var layer = trafficLayer._layers[layerId];
						
						&#x2F;&#x2F; if the incident ids match, we found it
						if (layer._incident.id == id)
							return layer;
						
					}
					
				}
				
				return null;
				
			},
			
			_checkRoutePoints: function(displayRouteId, pointIndex, options) {
								
				&#x2F;&#x2F; make sure the route id still matches
				if (this._displayRouteId != displayRouteId)
					return;
				
				var currentPoint = this._originalRoutePoints[pointIndex];
				
				&#x2F;&#x2F; check to see if the current point is a string
				if (typeof(currentPoint) == &quot;string&quot;) {
					
					var geocodingService = this.geocodingService;
					
					&#x2F;&#x2F; call the geocoding service to get the latitude &#x2F; longitude
					geocodingService.geocode(currentPoint, L.Util.bind(function(response) {

						&#x2F;&#x2F; make sure the route id still matches
						if (this._displayRouteId != displayRouteId)
							return;
						
						&#x2F;&#x2F; make sure the point was located
						if (response.geoResponse &amp;&amp; response.geoResponse.geoResult) {
							
							var result = response.geoResponse.geoResult;
							var point = null;
							
							&#x2F;&#x2F; check to see if multiple results were returned
							if (result.length != null) {
								point = L.latLng([
									result[0].latitude,
									result[0].longitude
								]);
							} else {
								point = L.latLng([
									result.latitude,
									result.longitude
								]);
							}
							
							this._routePoints.push(point);
							
							&#x2F;&#x2F; add intermediate points to the waypoints collection
							if (pointIndex &gt; 0 &amp;&amp; pointIndex + 1 &lt; this._originalRoutePoints.length)
								this._addRouteWaypoint(point);
							
							pointIndex++;
							
							if (pointIndex &gt;= this._originalRoutePoints.length) {
								this._getRoute(displayRouteId, options);
							} else {
								this._checkRoutePoints(displayRouteId, pointIndex, options);
							}
							
						} else if (options.callback) {
							options.callback({ error: &quot;Geocode failed for point &quot; + pointIndex });
						}
						
					}, this));
				
				} else { &#x2F;&#x2F; if the point is not a string, then it must be a lat &#x2F; lng pair, which doesn&#x27;t need processing

					if (pointIndex &gt;= this._originalRoutePoints.length) {
						this._getRoute(displayRouteId, options);
					} else {
						this._routePoints.push(L.latLng(this._originalRoutePoints[pointIndex]));
						this._checkRoutePoints(displayRouteId, pointIndex + 1, options);
					}
				}
				
			},
			
			_getRoute: function(displayRouteId, options, changeExtent) {
				
				if (typeof(changeExtent) == &quot;undefined&quot;)
					changeExtent = true;
				
				&#x2F;&#x2F; make sure the route id still matches
				if (this._displayRouteId != displayRouteId)
					return;
				
				var routingSerive = new tomtom.services.RoutingService(this.apiKey);
				
				&#x2F;&#x2F; use the map&#x27;s traffic model
				if (this.trafficModel)
					options.trafficModelId = this.trafficModel;
				
				&#x2F;&#x2F; set the path points to get vector information
				options.pathPoints = 17;
				
				&#x2F;&#x2F; get the route
				routingSerive.getRoute(this._getUpdatedRoutePoints(), options, L.Util.bind(function(response) {
					
					this._displayingRoute = true;
					
					if (response.route) {
						
						this._currentRoute = response.route;
						
						if (changeExtent &amp;&amp; (typeof(options.updateBounds) == &quot;undefined&quot; || options.updateBounds)) {
							
							&#x2F;&#x2F; get the route&#x27;s bounding box
							var box = response.route.summary.bbox;
							
							&#x2F;&#x2F; zoom to the route&#x27;s bounds
							this.fitBounds([[box.bottomLeft.latitude, box.bottomLeft.longitude], [box.topRight.latitude, box.topRight.longitude]]);
							
						}
						
						&#x2F;&#x2F; add the route layer
						this._addRouteLayer();
						
					} else {
						
						this.log.error(&quot;An error occurred during routing&quot;, response);
						
						this.hideLoadingMessage();
						
					}
					
					&#x2F;&#x2F; call the user&#x27;s route callback
					if (this._routingCallback)
						this._routingCallback(response);
					
					&#x2F;&#x2F; fire the route end event
					this.fire(&quot;routeend&quot;, response);
					
					this._displayingRoute = false;
					
				}, this));
				
			},
			
			_addRouteLayer: function() {
				
				&#x2F;&#x2F; make sure a route has been created
				if (this._currentRoute) {
					
					&#x2F;&#x2F; check to see if the route layer already exists
					if (this._routeLayer) {
						this.removeLayer(this._routeLayer);
						this._routeLayer = null;
					}
					
					&#x2F;&#x2F; check to see if the traffic marker layer exists
					if (!this._routeMarkerLayer)
						this._routeMarkerLayer = L.layerGroup().addTo(this);
					
					&#x2F;&#x2F; add the route layer
					this._routeLayer = L.polyline([], this.routeStyle).addTo(this);
					
					var lats = this._currentRoute.pathPoints.latitude;
					var lons = this._currentRoute.pathPoints.longitude;
					var points = [];
					
					if (lats.length &gt; 0) {
						
						var lat = lats[0], lon = lons[0];
						
						&#x2F;&#x2F; add the route points
						for (var pointIndex = 0; pointIndex &lt; lats.length; pointIndex++) {
							&#x2F;&#x2F; every point after the first point is an offset
							if (pointIndex &gt; 0) {
								lat += lats[pointIndex];
								lon += lons[pointIndex];
							}
							
							&#x2F;&#x2F; add the point to the point list
							points.push(new L.LatLng(lat, lon));
						}
						
						&#x2F;&#x2F; leaflet automatically simplifies poly lines, no need to do that here
						this._routeLayer.setLatLngs(points);
						
						&#x2F;&#x2F; make sure the waypoints snap onto the route
						this._updateWaypoints();
						
					}
					
					&#x2F;&#x2F; handle route line dragging
					this._routeLayer.on(&quot;mousedown&quot;, function(e) {
						
						if (e.originalEvent.button == 2)
							return;
						
						this._currentWaypoint = this._addRouteWaypoint(e.latlng);
						
					}, this);
					
					this.hideLoadingMessage();
					this._updateRouteMarkers();				
					
				}
				
				this._isRoutingExecuting = false;
				
				&#x2F;&#x2F; check the queue of routing requests
				if (this._routeCallQueue.length &gt; 0) {
					
					&#x2F;&#x2F; get only the last route requested
					var routeParameters = this._routeCallQueue.pop();
					
					&#x2F;&#x2F; call the display route function
					this.displayRoute(routeParameters.points, routeParameters.options, routeParameters.callback);
					
					&#x2F;&#x2F; clear out the queue
					this._routeCallQueue = [];
					
				}
				
			},
			
			_addRouteWaypoint: function(latLng, checkPointIndex) {
				
				if (typeof(checkPointIndex) == &quot;undefined&quot;)
					checkPointIndex = true;
				
				if (this._routeWaypoints.length &lt; 3) {
					
					var circle = new tomtom.Marker(latLng, WAYPOINT_MARKER_OPTIONS);
					
					this.addLayer(circle);
					circle.setContextMenu(this._waypointContextMenu);
					
					&#x2F;&#x2F; make the circle movable
					L.DomEvent.on(circle._icon, &quot;mousedown&quot;, function(e) {
						
						L.DomEvent.stop(e);
						
						this._currentWaypoint = circle;
						
						return false;
						
					}, this);
					
					L.DomEvent.on(circle._icon, &quot;dragstart&quot;, function(e) {
						
						L.DomEvent.stop(e);
						return false;
						
					});
					
					var waypointIndex = 0;
					var minDistance = null;
					var routePoints = this._getUpdatedRoutePoints();
					
					if (checkPointIndex) {
						&#x2F;&#x2F; figure out where in the array the waypoint should be added
						routePoints.forEach(function(currentLatLng, index) {
							
							if (index + 1 &lt; routePoints.length) {
								
								var nextLatLng = routePoints[index + 1];
								
								&#x2F;&#x2F; check the distance from the current segment
								var distance = L.LineUtil.pointToSegmentDistance(
										new L.Point(latLng.lat, latLng.lng),
										new L.Point(currentLatLng.lat, currentLatLng.lng),
										new L.Point(nextLatLng.lat, nextLatLng.lng)
								);
								
								if (minDistance == null || distance &lt; minDistance) {
									minDistance = distance;
									waypointIndex = index + 1;
								}
								
							}
							
						}, this);
						
						&#x2F;&#x2F; subtract one, as the waypoints are stored in a separate array from the start &#x2F; end
						if (waypointIndex &gt; 0)
							waypointIndex--;
						
						this._routeWaypoints.splice(waypointIndex, 0, circle);
					} else
						this._routeWaypoints.push(circle);
					
					return circle;
					
				}
				
			},
			
			_removeWaypoint: function(e) {
				
				&#x2F;&#x2F; remove the marker
				this.removeLayer(e.targetObject);
				
				&#x2F;&#x2F; remove the waypoint
				this._routeWaypoints.splice(this._routeWaypoints.indexOf(e.targetObject), 1);

				var options = L.Util.extend({ showLoading: false, updateMarkers: false, updateBounds: false, checkPoints: false }, this._currentRouteOptions);
				
				&#x2F;&#x2F; re-display the route
				this.displayRoute([], options);
				
				&#x2F;&#x2F; remove the context menu targets
				this._waypointContextMenu.removeTarget(e.targetElement);
				
			},
			
			_handleMouseMove: function(e) {
				
				if (this._currentWaypoint != null) {
					
					&#x2F;&#x2F; update the waypoint&#x27;s latlng
					this._currentWaypoint.setLatLng(e.latlng);
					
					var options = {};
					
					options = L.Util.extend({ showLoading: false, updateMarkers: false, updateBounds: false, checkPoints: false }, this._currentRouteOptions);
					
					&#x2F;&#x2F; display the route
					this.displayRoute([], options);
					
					L.DomEvent.stop(e);
					
					return false;
					
				}
				
			},
			
			_getUpdatedRoutePoints: function() {
				
				var routePoints = [];
				
				&#x2F;&#x2F; add the start
				routePoints.push(this._routePoints[0]);
				
				&#x2F;&#x2F; add each waypoint
				this._routeWaypoints.forEach(function(waypoint) {
					routePoints.push(waypoint.getLatLng());
				}, this);
				
				&#x2F;&#x2F; add the end point
				routePoints.push(this._routePoints[this._routePoints.length - 1]);
				
				return routePoints;
				
			},
			
			_handleMouseUp: function() {
				
				this._currentWaypoint = null;
				
				if (this._waypointsNeedUpdate &amp;&amp; !this._isRoutingExecuting)
					this._updateWaypoints();
				
			},
			
			_updateWaypoints: function() {
				
				&#x2F;&#x2F; wait untilthe user has dropped the waypoint
				if (this._currentWaypoint != null)
					return;
				
				this._waypointsNeedUpdate = false;
				
				&#x2F;&#x2F; update waypoint markers, snap them onto the route
				this._routeWaypoints.forEach(function(waypoint) {
					
					var minDistance = 99999999;
					var closestLatLng = null;
					
					&#x2F;&#x2F; find the closest point on the route
					this._routeLayer.getLatLngs().some(function(point) {
					
						var distance = point.distanceTo(waypoint.getLatLng());
						
						if (distance &lt; minDistance) {
							minDistance = distance;
							closestLatLng = point;
						}
						
					});
					
					&#x2F;&#x2F; snap to the route
					waypoint.setLatLng(closestLatLng);
					
				}, this);
				
			},
			
			_updateRouteMarkers: function() {
				
				var options = this._currentRouteOptions;
				var instructions = this._currentRoute.instructions.instruction;
				var start = instructions[0];
				var end = instructions[instructions.length - 1];
				
				var updateRouteFromMarkers = function() {
					
					var options = L.Util.extend({ showLoading: false, updateMarkers: false, updateBounds: false }, this._currentRouteOptions);
						
					this.displayRoute(
						[this._startMarker.getLatLng(), this._endMarker.getLatLng()], 
						options
					);
					
				};
				
				var markersExist = false;
				
				&#x2F;&#x2F; create the start marker if it doesn&#x27;t already exist
				if (!this._startMarker) {
					this._startMarker = new tomtom.Marker([start.point.latitude, start.point.longitude], tomtom.Map.MARKER_OPTIONS_ROUTE_START, { draggable: true });
					this._startMarker.on(&quot;drag&quot;, updateRouteFromMarkers, this);
				} else
					markersExist = true;
				
				&#x2F;&#x2F; create the end marker if it doesn&#x27;t already exist
				if (!this._endMarker) {
					this._endMarker = new tomtom.Marker([end.point.latitude, end.point.longitude], tomtom.Map.MARKER_OPTIONS_ROUTE_END, { draggable: true });
					this._endMarker.on(&quot;drag&quot;, updateRouteFromMarkers, this);
				} else
					markersExist = true;
				
				&#x2F;&#x2F; if the markers should be moved
				if (markersExist &amp;&amp; typeof(options.updateMarkers) == &quot;undefined&quot; || options.updateMarkers) {
					this._startMarker.setLatLng([start.point.latitude, start.point.longitude]);
					this._endMarker.setLatLng([end.point.latitude, end.point.longitude]);
				}
				
				&#x2F;&#x2F; add the route markers
				this._routeMarkerLayer.addLayer(this._startMarker);
				this._routeMarkerLayer.addLayer(this._endMarker);
				
			},
			
			_updateViewport: function(updateTraffic) {
				
				var viewportService = new tomtom.services.ViewportService(this.apiKey);
				var bounds = this.getBounds();
				var extent = {
					top: bounds.getNorthEast().lat,
					right: bounds.getNorthEast().lng,
					bottom: bounds.getSouthWest().lat,
					left: bounds.getSouthWest().lng
				};
				
				&#x2F;&#x2F; make a call to the viewport API to get the traffic model
				viewportService.getViewportModel(extent, this.getZoom(), extent, this.getZoom(),
						{ projection: &quot;EPSG4326&quot;, copyright: false },
						L.Util.bind(function(response) {
				
							if (response.viewpResp) {
								
								this._updateAttribution(response.viewpResp);
								
								&#x2F;&#x2F; if traffic should be displayed and a traffic model was returned update the traffic layers
								if (this._displayTraffic &amp;&amp; response.viewpResp.trafficState &amp;&amp; response.viewpResp.trafficState[&quot;@trafficModelId&quot;]) {
									var trafficModelId = this.trafficModel = response.viewpResp.trafficState[&quot;@trafficModelId&quot;];
								
									if (updateTraffic) {
										&#x2F;&#x2F; make sure the traffic layer hasn&#x27;t already been added
										if (this._trafficLayer == null) {
											&#x2F;&#x2F; create the traffic layer
											this._trafficLayer = new tomtom.layers.TrafficLayer(this.apiKey, trafficModelId);
								        	this.addLayer(this._trafficLayer);
										} else {
											this._trafficLayer.update(trafficModelId);
										}
										
										&#x2F;&#x2F; make sure the traffic incident layer hasn&#x27;t already been created
										if (this._trafficIncidentLayer == null) {
											&#x2F;&#x2F; create the traffic incident layer
											this._trafficIncidentLayer = new tomtom.layers.TrafficIncidentLayer(this.apiKey, trafficModelId);
											this.addLayer(this._trafficIncidentLayer);
											this._trafficIncidentLayer.update(true, trafficModelId);
										} else {
											this._trafficIncidentLayer.update(true, trafficModelId);
										}
									} else if (this._trafficLayer) {
										this._trafficLayer.setTrafficModel(trafficModelId);
										this._trafficIncidentLayer.setTrafficModel(trafficModelId);
									}
								}
								
							}

				}, this));
				
			},
			
			_registerViewportUpdateTimeout: function() {
				
				clearTimeout(this._viewportUpdateTimeoutId);
				
				this._viewportUpdateTimeoutId = setTimeout(L.Util.bind(function() {
					
					&#x2F;&#x2F; update the traffic incidents
					if (this._trafficIncidentLayer)
						this._trafficIncidentLayer.update(true, this.trafficModelId);
					
					&#x2F;&#x2F; update the viewport, but do not update the traffic
					this._updateViewport(false);
					
				}, this), 500);
				
			},
			
			_fireLoad: function() {
				
				this._baseLayer.off(&quot;load&quot;, this._fireLoad);				
				this.fire(&quot;load&quot;);
				
			},
			
			_handleZoomChange: function() {
				
				this._addRouteLayer();
				
			},
			
			_handleMapMove: function() {
				
				var center = this.getCenter();
		        
		        &#x2F;&#x2F; keep the map location in a cookie
		        if (this.options.cookie)
		        	utils.setCookie(this.options.cookie.name, center.lat + &quot;,&quot; + center.lng + &quot;,&quot; + this.getZoom(), this.options.cookieExpirationDays);
		        
		        &#x2F;&#x2F; update the viewport
		        this._registerViewportUpdateTimeout();
				
			},
			
			_destroyAttribution: function() {
				
				this._attributionClickHandlers.forEach(function(clickHandler) {
					du.off(clickHandler.element, &quot;click&quot;, clickHandler.handler);
				});
				
				this._attributionClickHandlers = [];
				
			},
			
			_updateAttribution: function(viewport) {
				
				this._destroyAttribution();
				
				&#x2F;&#x2F; remove the current TomTom attribution
				if (this._currentAttribution)
					this.attributionControl.removeAttribution(this._currentAttribution);
				
				this._currentAttribution = &quot;&quot;;
				
				&#x2F;&#x2F; split up the returned copyright info
				var copyrightIds = viewport.copyrightIds.toString().split(&quot;^&quot;);
				
				for (var copyrightIndex = 0; copyrightIndex &lt; copyrightIds.length; copyrightIndex++) {
					
					var info = this._copyrightInfo[copyrightIds[copyrightIndex]];
					
					if (info) {
						this._currentAttribution += &quot;&lt;a href=\&quot;javascript:void(0);\&quot; data-id=\&quot;&quot; + info[&quot;@id&quot;] + &quot;\&quot;&gt;&quot;
							+ info.label + &quot;&lt;&#x2F;a&gt; &quot;;
					}
					
				}
				
				&#x2F;&#x2F; add the attribution to the attribution control
				this.attributionControl.addAttribution(this._currentAttribution);				
				
				&#x2F;&#x2F; connect to click events on attribution links
				du.query(&quot;a&quot;, this.attributionControl._container).each(function(element) {
					
					var clickHandler = function(e) {
						this._attributionClick(du.attr(element, &quot;data-id&quot;), element, e);
					};
					
					this._attributionClickHandlers.push({ element: element, handler: clickHandler });
					
					du.on(element, &quot;click&quot;, clickHandler, this);
					
				}, this);
				
			},
			
			_attributionClick: function(id, element, e) {
				
				&#x2F;&#x2F; if an id was not supplied, don&#x27;t bother looking up the copyright info
				if (id) {
				
					&#x2F;&#x2F; get the copyright info which was loaded by the initialize call
					var copyrightInfo = this._copyrightInfo[id];
					
					&#x2F;&#x2F; make sure the copyright info was found, in case the viewport API returns something the initialize API doesn&#x27;t know about
					if (copyrightInfo) {
						
						&#x2F;&#x2F; pre load the image
						var image = document.createElement(&quot;img&quot;);
						
						&#x2F;&#x2F; create the popup once the image finishes loading
						L.DomEvent.on(image, &quot;load&quot;, function() {
							
							var container = du.create(&quot;div&quot;, &quot;leaflet-popup&quot;);
							
							var closeButton = du.create(&quot;a&quot;, &quot;leaflet-popup-close-button&quot;).html(&quot;x&quot;).attr(&quot;href&quot;, &quot;#close&quot;);
							container.append(closeButton);
							container.css(&quot;opacity&quot;, 1);
							
							var contentWrapper = du.create(&quot;div&quot;, &quot;leaflet-popup-content-wrapper&quot;);
							container.append(contentWrapper);
							
							var content = du.create(&quot;div&quot;, &quot;leaflet-popup-content&quot;)
								.html(&quot;&lt;div class=\&quot;copyrightInfo\&quot;&gt;&lt;img src=\&quot;&quot; + 
										copyrightInfo.logo + &quot;\&quot; class=\&quot;copyrightLogo\&quot; &#x2F;&gt;&quot; + 
										copyrightInfo.description + &quot;&lt;&#x2F;div&gt;&quot;);
							
							contentWrapper.append(content);
							
							this._container.appendChild(container.get());
							
							&#x2F;&#x2F; place the popup in the center of the screen
							var dimensions = du.dimensions(this._container);
							
							container.css(&quot;top&quot;, ((dimensions.height - container.offsetHeight()) &#x2F; 2) + &quot;px&quot;);
							container.css(&quot;left&quot;, ((dimensions.width - container.offsetWidth()) &#x2F; 2) + &quot;px&quot;);
							
							&#x2F;&#x2F; handle the close button
							closeButton.on(&quot;click&quot;, function(e) {
								this._container.removeChild(container.get());
								L.DomEvent.stop(e);
							}, this);
						
						}, this);
						
						image.src = copyrightInfo.logo;
						L.DomEvent.stop(e || event);
					
					}
					
				}
				
			}
			
		});
		
		&#x2F;&#x2F; ** Other documentation items that aren&#x27;t a part of the class ** &#x2F;&#x2F;
		
		&#x2F;**
		 * Adds the given control to the map.
		 * @method addControl
		 * @param {L.IControl} control The control to add to the map.
		 *&#x2F;
		
		&#x2F;**
		 * Removes the given control from the map.
		 * @method removeControl
		 * @param {L.IControl} control The control to remove from the map.
		 *&#x2F;
		
		&#x2F;**
		 * Sets the view of the map (geographical center and zoom). If forceReset is set to true, the map is reloaded even if it&#x27;s eligible for pan or zoom animation (false by default).
		 * @method setView
		 * @param {L.LatLng} center The center location to pan the map to.
		 * @param {Number} zoom The zoom level to set the map to.
		 * @param {Boolean} [forceReset=false] If true, the map is reloaded even if it&#x27;s eligible for pan or zoom animation.
		 *&#x2F;
		
		&#x2F;**
		 * Sets the zoom level of the map.
		 * @method setZoom
		 * @param {Number} zoom The zoom level to set the map to.
		 *&#x2F;
		
		&#x2F;**
		 * Increases the zoom of the map by delta (1 by default).
		 * @method zoomIn
		 * @param {Number} [delta=1] The amount to zoom by.
		 *&#x2F;
		
		&#x2F;**
		 * Decreases the zoom of the map by delta (1 by default).
		 * @method zoomOut
		 * @param {Number} [delta=1] The amount to zoom by.
		 *&#x2F;
		
		&#x2F;**
		 * Sets a map view that contains the given geographical bounds with the maximum zoom level possible.
		 * @method fitBounds
		 * @param {L.LatLngBounds} bounds The bounds to fit the map view to.
		 *&#x2F;
		
		&#x2F;**
		 * Sets a map view that mostly contains the whole world with the maximum zoom level possible.
		 * @method fitWorld
		 *&#x2F;
		
		&#x2F;**
		 * Pans the map to a given center. Makes an animated pan if new center is not more than one screen away from the current one.
		 * @method panTo
		 * @param {L.LatLng} latlng The lat &#x2F; lng to pan to.
		 *&#x2F;
		
		&#x2F;**
		 * Pans the map to the closest view that would lie inside the given bounds (if it&#x27;s not already).
		 * @method panInsideBounds
		 * @param {L.LatLngBounds} bounds The bounds to try and pan to.
		 *&#x2F;
		
		&#x2F;**
		 * Pans the map by a given number of pixels (animated).
		 * @method panBy
		 * @param {L.Point} point The number of x &#x2F; y units to pan the map by.
		 *&#x2F;
		
		&#x2F;**
		 * Checks if the map container size changed and updates the map if so — call it after you&#x27;ve changed the map size dynamically. If animate is true, map animates the update.
		 * @method invalidateSize
		 * @param {Boolean} [animate=false] If true, the resize will be animated.
		 *&#x2F;
		
		&#x2F;**
		 * Restricts the map view to the given bounds (see map maxBounds option).
		 * @method setMaxBounds
		 * @param {L.LatLngBound} bounds The bounds to restrict the map to.
		 *&#x2F;
		
		&#x2F;**
		 * Tries to locate the user using Geolocation API, firing locationfound event with location data on success or locationerror event on failure, and optionally sets the map view to the user location with respect to detection accuracy (or to the world view if geolocation failed). See Locate options for more details.
		 * @method locate
		 * @param {L.LocateOptions} [options] The options to use when locating the user.
		 * @param {Boolean} [options.watch=false] If true, starts continous watching of location changes (instead of detecting it once) using W3C watchPosition method. You can later stop watching using map.stopLocate() method.
		 * @param {Boolean} [options.setView=false] If true, automatically sets the map view to the user location with respect to detection accuracy, or to world view if geolocation failed.
		 * @param {Number} [options.maxZoom=Infinity] The maximum zoom for automatic view setting when using &#x60;setView&#x60; option.
		 * @param {Number} [options.timeout=10000] Number of millisecond to wait for a response from geolocation before firing a locationerror event.
		 * @param {Number} [options.maximumAge=0] Maximum age of detected location. If less than this amount of milliseconds passed since last geolocation response, locate will return a cached location.
		 * @param {Boolean} [options.enableHighAccuracy=false] Enables high accuracy, see http:&#x2F;&#x2F;dev.w3.org&#x2F;geo&#x2F;api&#x2F;spec-source.html#high-accuracydescription.
		 *&#x2F;
		
		&#x2F;**
		 * Stops watching location previously initiated by map.locate({watch: true}).
		 * @method stopLocate
		 *&#x2F;
		
		&#x2F;**
		 * Returns the geographical center of the map view.
		 * @method getCenter
		 *&#x2F;
		
		&#x2F;**
		 * Returns the current zoom of the map view.
		 * @method getZoom
		 *&#x2F;
		
		&#x2F;**
		 * Returns the minimum zoom level of the map.
		 * @method getMinZoom
		 *&#x2F;
		
		&#x2F;**
		 * Returns the maximum zoom level of the map.
		 * @method getMaxZoom
		 *&#x2F;
		
		&#x2F;**
		 * Returns the LatLngBounds of the current map view.
		 * @method getBounds
		 *&#x2F;
		
		&#x2F;**
		 * Returns the maximum zoom level on which the given bounds fit to the map view in its entirety. If inside (optional) is set to true, the method instead returns the minimum zoom level on which the map view fits into the given bounds in its entirety.
		 * @getBoundsZoom
		 * @param {L.LatLngBounds} bounds The bounds to get the zoom level for.
		 * @param {Boolean} [inside=false] If true, determines the minimum zoom in which the map view will fit.
		 *&#x2F;
		
		&#x2F;**
		 * Returns the current size of the map container.
		 * @method getSize
		 *&#x2F;
		
		&#x2F;**
		 * Adds the given layer to the map. If optional insertAtTheBottom is set to true, the layer is inserted under all others (useful when switching base tile layers).
		 * @method addLayer
		 * @param {Boolean} [insertAtTheBottom=false]
		 *&#x2F;
		
		&#x2F;**
		 * Removes the given layer from the map.
		 * @method removeLayer
		 * @param {L.ILayer} layer The layer to remove.
		 *&#x2F;
		
		&#x2F;**
		 * Returns true if the given layer is currently added to the map.
		 * @method hasLayer
		 * @param {L.ILayer} layer The layer to check.
		 *&#x2F;
		
		&#x2F;**
		 * Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
		 * @method openPopup
		 * @param {Popup} popup The popup to open.
		 *&#x2F;
		
		&#x2F;**
		 * Closes the popup opened with openPopup.
		 * @method closePopup
		 *&#x2F;
		
		&#x2F;**
		 * Registers an event handler for the map.
		 * @method on
		 * @param {String} eventName The name of the event to attach to.
		 * @param {Function} callback The function to call when the event is Fired.
		 * @param {Object} [scope] The scope to execute the callback in.
		 *&#x2F;
		
		&#x2F;**
		 * Returns the map layer point that corresponds to the given geographical coordinates (useful for placing overlays on the map).
		 * @method latLngToLayerPoint
		 * @param {L.LatLng} latlng 
		 * @returns L.Point
		 *&#x2F;
		
		&#x2F;**
		 * Returns the geographical coordinates of a given map layer point.
		 * @method layerPointToLatLng
		 * @param {L.Point} point
		 * @returns L.LatLng
		 *&#x2F;
		
		&#x2F;**
		 * Converts the point relative to the map container to a point relative to the map layer.
		 * @method containerPointToLayerPoint
		 * @param {L.Point} point
		 * @returns L.Point
		 *&#x2F;
		
		&#x2F;**
		 * Converts the point relative to the map layer to a point relative to the map container.
		 * @method layerPointToContainerPoint
		 * @param {L.Point} point
		 * @returns L.Point
		 *&#x2F;
		
		&#x2F;**
		 * Returns the map container point that corresponds to the given geographical coordinates.
		 * @method latLngToContainerPoint
		 * @param {L.LatLng} latlng
		 * @returns L.Point
		 *&#x2F;
		
		&#x2F;**
		 * Returns the geographical coordinates of a given map container point.
		 * @method containerPointToLatLng
		 * @param {L.Point} point
		 * @returns L.LatLng
		 *&#x2F;
		
		&#x2F;**
		 * Projects the given geographical coordinates to absolute pixel coordinates for the given zoom level (current zoom level by default).
		 * @method project
		 * @param {L.LatLng} latlng
		 * @param {Number} [zoom]
		 * @returns L.Point
		 *&#x2F;
		
		&#x2F;**
		 * Projects the given absolute pixel coordinates to geographical coordinates for the given zoom level (current zoom level by default).
		 * @method unproject
		 * @param {L.Point} point
		 * @param {Number} [zoom]
		 * @returns L.LatLng
		 *&#x2F;
		
		&#x2F;**
		 * Returns the pixel coordinates of a mouse click (relative to the top left corner of the map) given its event object.
		 * @method mouseEventToContainerPoint
		 * @param {L.MouseEvent} event
		 * @returns L.Point
		 *&#x2F;
		
		&#x2F;**
		 * Returns the pixel coordinates of a mouse click relative to the map layer given its event object.
		 * @method mouseEventToLayerPoint
		 * @param {L.MouseEvent} event
		 * @returns L.Point
		 *&#x2F;
		
		&#x2F;**
		 * Returns the geographical coordinates of the point the mouse clicked on given the click&#x27;s event object.
		 * @method mouseEventToLatLng
		 * @param {L.MouseEvent} event
		 * @returns L.LatLng
		 *&#x2F;
		
		&#x2F;**
		 * Fired when the map and its base layer have completed loading.
		 * @event load
		 *&#x2F;
		
		&#x2F;**
		 * Fired when a new layer is added to the map.
		 * @event layeradd
		 *&#x2F;
		
		&#x2F;**
		 * Fired when some layer is removed from the map.
		 * @event layerremove
		 *&#x2F;
		
		&#x2F;**
		 * Fired when the base layer is changed through the layer control.
		 * @event baselayerchange
		 *&#x2F;
		
		&#x2F;**
		 * Fired after the start of a drag, pan, or zoom.
		 * @event movestart
		 *&#x2F;
		
		&#x2F;**
		 * Fired after each drag, pan, or zoom
		 * @event move
		 *&#x2F;
		
		&#x2F;**
		 * Fired after a drag, pan, or zoom completes
		 * @event moveend
		 *&#x2F;
		
		&#x2F;**
		 * Fired after a zoom completes
		 * @event zoomend
		 *&#x2F;
		
		&#x2F;**
		 * Fired after a zoom completes
		 * @event zoomstart
		 *&#x2F;
		
		&#x2F;**
		 * Fired after mouseover the map
		 * @event mouseover
		 *&#x2F;
		
		&#x2F;**
		 * Fired after mouseout the map
		 * @event mouseout
		 *&#x2F;
		
		&#x2F;**
		 * Fired after mousemove the map
		 * @event mousemove
		 *&#x2F;
		
		&#x2F;**
		 * Fired when the user clicks the mouse button.
		 * @event mousedown
		 *&#x2F;
		
		&#x2F;**
		 * Fired when the user releases the mouse button.
		 * @event mouseup
		 *&#x2F;
		
		&#x2F;**
		 * Fired when the user releases the mouse button.
		 * @event click
		 *&#x2F;
		
		&#x2F;**
		 * Fired when the user double clicks the map.
		 * @event dblclick
		 *&#x2F;
		
		&#x2F;**
		 * Fired after the base layer changes
		 * @event changebaselayer
		 *&#x2F;
		
		&#x2F;**
		 * Fired when geolocation (using locate method) went successfully.
		 * @event locationfound
		 *&#x2F;
		
		&#x2F;**
		 * Fired when geolocation (using locate method) failed.
		 * @event locationerror
		 *&#x2F;
		
		&#x2F;**
		 * Fired when a popup is opened (using openPopup method).
		 * @event popupopen
		 *&#x2F;

		&#x2F;**
		 * Fired when a popup is closed (using closePopup method).
		 * @event popupclose
		 *&#x2F;
		
		&#x2F;&#x2F; ** end  ** &#x2F;&#x2F;
		
		var TRAFFIC_UPDATE_INTERVAL = 120000;
		var LAYER_INDEX_BASE = 0;
		var LAYER_INDEX_TRAFFIC = 1;
		var LAYER_INDEX_ROUTE = 2;
		var LAYER_INDEX_TRAFFIC_INCIDENTS = 48;
		var LAYER_INDEX_ROUTE_MARKERS = 49;
		var LAYER_INDEX_MARKERS = 50;
		var INSTRUCTION_ZOOM_LEVEL = 16;
		var WAYPOINT_MARKER_OPTIONS = { iconUrl: &quot;waypoint.png&quot;, iconSize: [10, 10], iconAnchor: [5, 5] };
		
		&#x2F;**
		 * The name of the default marker layer.
		 *&#x2F;
		tomtom.Map.MARKER_LAYER_DEFAULT = &quot;DEFAULT&quot;;
		
		&#x2F;**
		 * The name of the traffic layer.
		 *&#x2F;
		tomtom.Map.MARKER_LAYER_TRAFFIC = &quot;TRAFFIC&quot;;
		
		&#x2F;**
		 * Defines the marker options for the route start point.
		 * @static
		 * @property MARKER_OPTIONS_ROUTE_START
		 *&#x2F;
		tomtom.Map.MARKER_OPTIONS_ROUTE_START = {
			iconUrl: &quot;marker_start.png&quot;, 
			iconSize: [ 43, 49 ],
   			iconAnchor: [ 11, 40 ],
   			popupAnchor: [ 0, 0 ]
		};
		
		&#x2F;**
		 * Defines the marker options for the route end point.
		 * @static
		 * @property MARKER_OPTIONS_ROUTE_END
		 *&#x2F;
		tomtom.Map.MARKER_OPTIONS_ROUTE_END = {
			iconUrl: &quot;marker_finish.png&quot;, 
			iconSize: [ 43, 49 ],
   			iconAnchor: [ 11, 40 ],
   			popupAnchor: [ 0, 0 ]
		};
		
		return tomtom.Map;
	}
);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
